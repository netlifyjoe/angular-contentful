{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/jkeyes/Development/netlify/solutions-engineering/angular-contentful/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nclass AbortError extends Error {\n  constructor() {\n    super('Throttled function aborted');\n    this.name = 'AbortError';\n  }\n\n}\n\nconst pThrottle = ({\n  limit,\n  interval,\n  strict\n}) => {\n  if (!Number.isFinite(limit)) {\n    throw new TypeError('Expected `limit` to be a finite number');\n  }\n\n  if (!Number.isFinite(interval)) {\n    throw new TypeError('Expected `interval` to be a finite number');\n  }\n\n  const queue = new Map();\n  let currentTick = 0;\n  let activeCount = 0;\n\n  function windowedDelay() {\n    const now = Date.now();\n\n    if (now - currentTick > interval) {\n      activeCount = 1;\n      currentTick = now;\n      return 0;\n    }\n\n    if (activeCount < limit) {\n      activeCount++;\n    } else {\n      currentTick += interval;\n      activeCount = 1;\n    }\n\n    return currentTick - now;\n  }\n\n  const strictTicks = [];\n\n  function strictDelay() {\n    const now = Date.now();\n\n    if (strictTicks.length < limit) {\n      strictTicks.push(now);\n      return 0;\n    }\n\n    const earliestTime = strictTicks.shift() + interval;\n\n    if (now >= earliestTime) {\n      strictTicks.push(now);\n      return 0;\n    }\n\n    strictTicks.push(earliestTime);\n    return earliestTime - now;\n  }\n\n  const getDelay = strict ? strictDelay : windowedDelay;\n  return function_ => {\n    const throttled = function (...args) {\n      var _this = this;\n\n      if (!throttled.isEnabled) {\n        return _asyncToGenerator(function* () {\n          return function_.apply(_this, args);\n        })();\n      }\n\n      let timeout;\n      return new Promise((resolve, reject) => {\n        const execute = () => {\n          resolve(function_.apply(this, args));\n          queue.delete(timeout);\n        };\n\n        timeout = setTimeout(execute, getDelay());\n        queue.set(timeout, reject);\n      });\n    };\n\n    throttled.abort = () => {\n      for (const timeout of queue.keys()) {\n        clearTimeout(timeout);\n        queue.get(timeout)(new AbortError());\n      }\n\n      queue.clear();\n      strictTicks.splice(0, strictTicks.length);\n    };\n\n    throttled.isEnabled = true;\n    return throttled;\n  };\n};\n\nmodule.exports = pThrottle;\nmodule.exports.AbortError = AbortError;","map":null,"metadata":{},"sourceType":"script"}